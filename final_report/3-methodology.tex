\section {Development Methodology}
\subsection{Way of Working}
\subsubsection{Communication and management}
\begin{itemize}
    \item During the 4 sprints we met each Tuesday and Wednesday, a total of 6 hours each week. We used this time to plan our work, work on the user stories and do retrospective meetings among other things. 
    \item For communication we used Slack, which is a team collaboration tool where teams can communicate and share files in private chats or in group channels. All the code was pushed to a Github repository using Git. Work was done on feature branches which were merged into a development branch when the code was deemed production ready. This was then merged into the master branch before the product was deployed. In addition, we used Trello as our task management board. This allowed us to keep track of what needed to be done and what people were working on. 
    \item The decision-making took place in the meetings, preferably with all team members present. This way we could get input from everyone and make good decisions we could all agree on. Less important decisions, such as minor implementation details, were left to the individual members.   
\end{itemize}

\subsection{Practices}
\subsubsection{Our practice cards}
\begin{itemize}
    \item User stories (Product backlog essentials -> Product backlog item)
    \item Use cases
    \item Sprint planning (Agile timeboxing essentials -> Plan a timebox)
    \item Sprint review (Agile timeboxing essentials -> Review a timebox)
    \item Sprint retrospective (Agile retrospective essentials -> Hold a retrospective)
    \item Product backlog (Product backlog essentials -> Product backlog)
    \item Sprint backlog (Product backlog essentials -> Splitting product backlog items)
    \item Unit test (Agile Development Essentials -> Test case)
    \item Self-Organizing Team (Agile teaming esssentials -> Self-Organizing team)
    \item Pair programming (Agile teaming essentials -> Share Knowhow)
    \item Continous integration (Agile development essentials -> Automate as much as possible)
    \item 2 week long sprints (Agile Timeboxing essentials -> Regular Heartbeat)
\end{itemize}

\subsubsection{How we built up our method}
To gain an overview of what needed to be done, we set up a product backlog and sorted it based on priority. We also estimated how long time it would take to finish each backlog item, to help us plan our Sprints. It contains user stories which essentially state what we want our product to do. In each sprint we chose which user stories to work on based on their priority and estimated time usage. Our team was self-organizing and to help share knowledge we used pair programming.

We built our SEMAT method using practice cards from Ivar Jacobson's Practice Library. There are a lot of different practices in Agile development, and this helped us focus on what we thought was most important.

\subsection{Technical infrastructure}
\begin{itemize}
    \item Front-end: Developed using Django, HTML, CSS and Javascript.
    \item Back-end: Django has built in support for the most popular SQL databases, so connecting Django and PostgreSQL was easy. Redis is an in-memory database which helps to make the site's performance better.
    \item Database: We originally planned to use a MySQL database, but we changed to PostgreSQL because it was more suitable for our product. The database was used to store user information, chat messages and to manage users present in the lobbies and chat rooms. 
    \item External frameworks: Our original plan was to use Centrifugo as our real-time messaging server. In Sprint 1 we discovered Django Channels and found this to be a better alternative. It performed the same functions, was easier to understand and allowed us to use something that was already integrated into Django.
    \item Development environment: The entire team developed in PyCharm by JetBrains, this helped the team keep up consistency. This also made it easier for us to collaborate on each others' machines.
    \item  Deployment approaches: The product will be delivered in a code package that can be deployed using Django's built-in deployment features. Installation procedures are included in our package.
\end{itemize}

\newpage
\subsection{Process metric}
\subsubsection{Activity plan with resource use}
\label{sec:act.plan w resources}
\begin{adjustbox}{center}
\begin{tabular}{ p{0.1\paperwidth} | p{0.1\paperwidth} | p{0.4\textwidth} | p{0.1\paperwidth} | p{0.1\paperwidth} }
    %
    Release due date 
    & Tasks 
    & Description
    & Est.\newline resource\newline use (h)
    & Actual \newline resource \newline use (h)\\ \hline
    %
    23.01.17 
    & Ideation report
    & Understanding the purpose and goal of the project
    & 32
    & 32 \\ \hline
    %
    03.02.17
    & Project Plan, Project Backlog
    & Pre-project documentation, gain an overview of the project
    & 46
    & 46 \\ \hline
    %
    10.02.17
    & Requirement and Architecture
    & 
    & 32 
    & 40 \\ \hline
    %
    24.02.17
    & Sprint 1
    & Get back-end up and running
    & 64 
    & 68 \\ \hline
    
    10.03.17
    & Sprint 2
    & Must have the ability to create and join chat rooms by now, basic application functionality in place
    & 64 
    & 70 \\ \hline
    %
    24.03.17
    & Sprint 3
    & Expanding functionality of the roBOT, adding required features, phone functionality
    & 64
    & 74 \\ \hline
    %
    07.04.17
    & Sprint 4
    & Polish, bug removal and front-end fixing. Testing
    & 64
    & 80 \\ \hline
    %
    27.04.17
    & Final report
    & Documentation and preparation for the final presentation
    & 64
    & 78 \\ \hline
    %
    & Total
    & 
    & 412
    & 488
\end{tabular}
\end{adjustbox}

\subsubsection{Size}
\begin{itemize}
    \item We chose to measure size by the number of lines of code we had written.
    \item These metrics are taken from Github's tracker, the first two numbers seem inflated since they contained a lot of frameworks and general code we didn't write.
    \item Code size per Core: 
\end{itemize}
\begin{adjustbox}{center}
\begin{tabular}{l|l|l} %{ p{0.2\paperwidth} | p{0.25\paperwidth} | p{0.3\paperwidth} }
        Core 1 & 960 additions & 0 deletions \\ \hline
        %
        Core 2 & 1580 additions & 1075 deletions \\ \hline
        %
        Core 3 & 332 additions & 181 deletions \\ \hline
        %
        Core 4 & 379 additions & 166 deletions \\ \hline
        %
        Undocumented/\break outside of core & 322 additions & 149 deletions \\
\end{tabular}
\end{adjustbox}

\subsubsection{Quality assurance}
We didn't allocate any time specifically to check for bugs. That happened continually while programming. It was each developers responsibility to push working code to Github. Whenever a bug was found, its fixing was top priority. We didn't do any dedicated integration tests, this also happened continually when pushing to Github, and when the branches were merged into the development branch.

Code review was done after Sprint 4, primarily to find and eliminate bugs in the system. We also made sure that the code was properly commented and followed our code conventions.
